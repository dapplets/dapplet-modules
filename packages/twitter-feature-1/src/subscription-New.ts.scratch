// ========= file Subscription.d.ts ==================
// common types
type Key = string | number | symbol
type MsgFilter = string | ((op:any, msg: any) => boolean)
type EventDef<T extends Key> = { [key in T]: MsgFilter }
type MsgHandler = ((op:string, msg: any) => void)
type EventHandler= { [key in Key]: MsgHandler }
type AutoProperty = {
  name: string
  set: (value:any)=>void 
}
class AutoPropertyConf {
  public idx=0
  constructor(public name: Key, public conn:Connection) { }
}

type AutoProperties<M> = { [key in keyof M]: AutoProperty }
type Listener = { f?: MsgFilter, h?: EventHandler, p?:AutoProperty[] }
// ========= file MyConnection.ts ==================
/*
//  define message types
type MsgType1 = {
  type:'T1'
  a:string
}

type MsgType2 = {
  type: 'T2'
  b:number
}

// type AllProps = keyof(MsgType2 & MsgType1)
type MsgTypes = MsgType1 | MsgType2
type AllProps = MsgType1 & MsgType2

//  define event types
type EventTypes = 'EVENT_ONE' | 'EVENT_TWO'
const EVENTS: EventDef<EventTypes> = {
    EVENT_ONE : (msg: MsgTypes) => msg.type == 'T1',
    EVENT_TWO : 'T2' //short form: the type only
}
*/
// ===============================
// ========= file Subscription.ts / Core.ts==================
const ANY_EVENT: any = Symbol('any_event')
const TYPE_FILTER = (type:string) => (op:any, msg:any) => msg.type === type

class Connection {
  private autoProperties = new Map<number, AutoProperty>() 
  public readonly listeners = new Map<number, Listener>()
  private nn=0 //a numeric handle counter to address listeners and autopropertes
  
  constructor(private eventDef?: EventDef<any>) { }

  send(op: any, msg: any): this {
    // make connection dependend work
    return this
  }

  receive(buf:any): this {
    // make connection dependend work
    //let { op, msg } = parseMessage(buf) 
    let op, msg
    this.onMessage(op, msg)
    return this
  }

  listen(h: EventHandler): this
  listen(f: MsgFilter, ap?: AutoProperty[]): this
  listen(f: MsgFilter, h: MsgHandler, ap?: AutoProperty[]): this
  listen(f: MsgFilter, h: EventHandler, ap?: AutoProperty[]): this
  listen(filterOrHander: MsgFilter | EventHandler, evtOrMsgOrAP?: EventHandler | MsgHandler | AutoProperty[], ap?:AutoProperty[]): this { 
    if (typeof filterOrHander === 'object') { //is an EventHandler
      this.listeners.set(++this.nn,{ f: undefined, h: filterOrHander })
    } else {
      if (evtOrMsgOrAP instanceof Array) {
        this.listeners.set(++this.nn, { f: filterOrHander, h: undefined, p: evtOrMsgOrAP })
      } else if (typeof evtOrMsgOrAP == 'function') {
        let h = { [ANY_EVENT]: evtOrMsgOrAP }
        this.listeners.set(++this.nn, { f: filterOrHander, h: h, p: ap })
      } else { 
        this.listeners.set(++this.nn, { f: filterOrHander, h: evtOrMsgOrAP!, p: ap })
      }
    }
    return this
  }

  //connection with AutoProperty support added by proxy
  static create<M>(eventsDef?:EventDef<any>): AutoProperties<M> & Connection {
    return new Proxy(new Connection(eventsDef), {
      get(conn: any, name, receiver) {
        let idx:number=0
        return name in conn ? conn[name] :
          Object.defineProperty(
            new AutoPropertyConf(name, conn),
            'set', {
              // if setter set, activate autoProp
              set: function (setter) {
                if (idx>0) conn.autoProperties.delete(idx)
                if (setter) idx = conn.addAutoProperty({ name: name, set: setter })
                else idx = 0
                return true
              }
            }
          )
      }
    })
  }

  private addAutoProperty(ap: AutoProperty):number { 
    this.autoProperties.set(++this.nn, ap)
    return this.nn
  }

  public addAutoProperties(f: MsgFilter, ap: AutoProperty[]): number {
    this.listeners.set(++this.nn,{ f: f, h: undefined, p: ap })
    return this.nn
  }

  topicMatch(topic: string, pattern: string): boolean {
    if (!pattern || pattern == topic) return true;
    else if (!topic) return false;

    let expected = pattern.split('.')
    let actual = topic.split('.')
    if (expected.length > actual.length) return false

    for (let i = 0; i < actual.length; ++i) {
      if (actual[i] != expected[i] && expected[i] != "*")
        return false
    }
    return true
  }

  onMessage(op: any, msg: any):void {
    const isTopicMatch = (op: any, msg: any, f: MsgFilter) =>
                    typeof f === 'string' ? this.topicMatch(op, f) : f(op, msg)
    this.listeners.forEach((listener) => { 
      if (!listener.f || isTopicMatch(op, msg, listener.f)) {
        if (listener.h) {
          for (let eventId of Object.keys(listener.h)) {
            let cond = this.eventDef ? this.eventDef[eventId] : eventId
            //ToDo: extract msg.type default
            if (typeof cond === 'function' ? cond(op, msg) : msg.type == cond) {
              listener.h[eventId](op, msg)
            }
          }
          listener.h[ANY_EVENT]?.(op, msg)
        }
        //push values to autoProperties
        for (let ap of listener.p || []) {
          ap && msg[ap.name] && ap.set(msg[ap.name])
        }
      }
    })
    //push values to autoProperties
    for (let ap of this.autoProperties.values()) {
      ap && msg[ap.name] && ap.set(msg[ap.name])
    }
  }

}//class Connection

class Core {
  static connect<M>(eventDef?:EventDef<any>): AutoProperties<M> & Connection {
    //ToDo: server specific
    return Connection.create(eventDef)
  }

  static wallet<M>(eventDef?:EventDef<any>): AutoProperties<M> & Connection {
    //ToDo: wallet specific
    return Connection.create(eventDef)
  }

  static overlay<M>(eventDef?:EventDef<any>): AutoProperties<M> & Connection {
    //ToDo: overlay specific
    return Connection.create(eventDef)
  }
}
// ========= file widgets.ts of dynamic adapter ===========

/*
type Ctx = {
  id:string
}

//Context related technical runtime info
type CtxRuntime = Ctx & {
  //save active subscriptions in ctx
  subs: WeakMap<Connection<any>,Subscription<any>>
}
type AutoPropertyConfig = { name: string, conn: Connection<any> }


*/
type WidgetState = { [key: string]: any }

function collectAutoProps(stateCfg: WidgetState) {
    let m = new Map<Connection, AutoPropertyConf[]>()
    Object.keys(stateCfg)
        .forEach((k: any) => Object.keys(stateCfg[k])
            .forEach((kk) => {
                let ap = stateCfg[k][kk]
                if (ap instanceof AutoPropertyConf) {
                    if (!m.has(ap.conn)) m.set(ap.conn, [ap])
                    else m.get(ap.conn)!.push(ap)
                }
            }))
    return m;
}
function createButton(stateCfg: WidgetState, ctx: any, apSetters: {[key:string]:(v:any)=>any}) {
  let m = collectAutoProps(stateCfg)
  if (!ctx.listeners) ctx.listeners=[]
  for (let [conn, apCfgList] of m.entries()) {
    let apList = apCfgList.map((p: any) => ({ name: p.name, set: apSetters[p.name] }))
    // introduce listener method
    // separate send() from listen()
    // make listener.remove()
    // send() list of autoproperties to listen
    // send() list of autoproperties to un-listen
    let h = conn.addAutoProperties(ctx.id, apList)
    ctx.listeners.push(h) //save handle for cleanup later
  }
}

function createContext(id: any, mm:Map<Connection,AutoPropertyConf[]>) { 
    mm.forEach((ap, conn) => {
        conn.send('context_start', { id:id, props: ap})
    })
    let ctx = { id: id, listeners:[] }
    return ctx
}

function destroyContext(ctx:any, mm:Map<Connection,AutoPropertyConf[]>){ 
  mm.forEach((ap, conn) => {
    conn.send('context_end', { id: ctx.id })
    ctx.listeners.forEach((h: any) => conn.listeners.delete(h))  
  })
}



/*

    (stateName: string, v: any) => {
    currentState[name]?.cleanUp?.() //cleanup before rewrite property - remove autoprop from sub
    if (v[PROP]) {
      let { conn, name } = v[PROP] as AutoPropertyConfig
      let sub = ctx.subs.get(conn)
      if (!sub) ctx.subs.set(conn, sub = conn.subscribe(ctx.id))
      let cleanUp = sub.addAutoProp(name, (value: any) => currentState[name].value = value)
      currentState[name] = { cleanUp: cleanUp, value: undefined }
    } else {
      currentState[name] = { cleanUp: undefined, value: v }
    }
  })
}
*/
// ========= file MyFeature.ts ==================
type M1 = {
  type: string,
  topic: string
  p1: string
  p2: string
}

type M2 = {
  key0: string,
  key1: string
}





const EVENTS_DEF = {
  TX_SENT:    (op: any, m: any) => m.type === "TX_SENT",
  WC_CONNECT: (op: any, m: any) => m.type === "WC_CONNECT",
  SWARM_NODE: (op: any, m: any) => m.type === "SWARM_NODE",
  SWARM_SENT: "SWARM_SENT"
} 

let _conn = Core.connect<M1&M2>(EVENTS_DEF) //EVENTS_DEF - optional mapping
  .send('ping', {})
  .listen("the.topic", {
    TX_SENT: (op: any, m: any) => { console.log("onTxSent  topic:", m.topic) },
    WC_CONNECT: (op: any, m: any) => { console.log("onWalletConnect  topic:", m.topic) }
  })
  .listen({
    SWARM_NODE: (op: any, m: any) => { console.log("onSwarmNode topic:", m.topic) },
    SWARM_SENT: (op: any, m: any) => { console.log("onSwarmSent topic:", m.topic) }
  })
  .listen("swarm.*", (op: any, m: any) => { console.log("ANY_EVENT onSwarmNode topic:", m.topic)});

let ap0:any = _conn.topic
ap0.set = (v: any) => console.log('CONNECTION_SET TOPIC_No1', v); //this setter gets overwritten by the next line
ap0.set = (v: any) => console.log('CONNECTION_SET TOPIC No2', v);
let ap1:any = _conn.topic;
ap1.set = (v: any) => console.log('CONNECTION_SET TOPIC No3', v);
let ap2:AutoProperty = _conn.topic

//==========context related Autoproperties=======================

let apSetters = (n:any)=> ({
  'p1': (v: any) => console.log(n+'[LISTENER SET.p1]',v),
  'p2': (v: any) => console.log(n+'[LISTENER SET.p2]',v),
  'topic': (v: any) => console.log(n+'[LISTENER SET.topic]',v),
  'type': (v:any)=>console.log(n+'[LISTENER SET.type]',v),
})

let BTN1_CONFIG = {
  DEFAULT: {
    topic: _conn.topic,
    p2: _conn.p2
  }
}
let m1 = collectAutoProps(BTN1_CONFIG)

let BTN2_CONFIG = {
  DEFAULT: {
    topic: _conn.topic,
    p2: _conn.p2
  },
  NEXT: {
    img: 'transition.img',
    type: _conn.type
  },
  FINALIZED: {
    hello: 'abracadabra.'
  }
}
let m2 = collectAutoProps(BTN2_CONFIG)
let mm=new Map([...m1, ...m2]) //all autoproperties from all widgets

let ctx123 = createContext('123', mm)

let btn11 = createButton(BTN1_CONFIG, ctx123, apSetters('btn_1_1:'))
let btn12 = createButton(BTN1_CONFIG, ctx123, apSetters('btn_1_2:'))


let ctx456 = createContext('456',mm)
let btn21 = createButton(BTN2_CONFIG, ctx456, apSetters('btn_2_1:'))
let btn22 = createButton(BTN2_CONFIG, ctx456, apSetters('btn_2_2:'))



console.log('#0')
_conn.onMessage('the.topic', { type: "WC_CONNECT", topic: "the.topic", p1:"1-1", p2:"1-2" })
console.log('#1')
_conn.onMessage('the.topic', { type: "TX_SENT", topic: "the.topic", p1: "2-1", p2: "2-2" })
console.log('#2')
_conn.onMessage('swarm.a', { type: "SWARM_NODE", topic: "swarm.topic",p1:"3-3", p2:"3-3" })
console.log('#4')
_conn.onMessage('swarm.b', { type: "SWARM_SENT", topic: "swarm.x" })
console.log('#4')
_conn.onMessage(ctx123.id, { type: "set_context", p1: "ctx123 1-1", p2: "ctx123 1-2" })
console.log('#5')
_conn.onMessage(ctx456.id, { type: "SET_CONTEXT", p1: "ctx456 1-1", p2: "ctx456 1-2" })
console.log('#6')

destroyContext(ctx123,mm)
destroyContext(ctx456, mm)

_conn.onMessage(ctx456.id, { type: "SET_CONTEXT", p1: "1-1", p2: "1-2" })
console.log('#7')
