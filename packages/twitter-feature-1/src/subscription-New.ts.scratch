// ========= file Subscription.d.ts ==================
// common types
type Key = string | number | symbol
type MsgFilter = string | ((op:any, msg: any) => boolean)
type EventDef<T extends Key> = { [key in T]: MsgFilter }
type MsgHandler = ((op:string, msg: any) => void)
type EventHandler= { [key in Key]: MsgHandler }
type AutoProperty = {
  name: string
  set: (value:any)=>void 
}
class AutoPropertyConf {
  public idx=0
  constructor(public name: Key, public conn:Connection) { }
}

type AutoProperties<M> = { [key in keyof M]: AutoProperty }
type Listener = { f?: MsgFilter, h?: EventHandler, p?:AutoProperty[] }
// ========= file MyConnection.ts ==================
/*
//  define message types
type MsgType1 = {
  type:'T1'
  a:string
}

type MsgType2 = {
  type: 'T2'
  b:number
}

// type AllProps = keyof(MsgType2 & MsgType1)
type MsgTypes = MsgType1 | MsgType2
type AllProps = MsgType1 & MsgType2

//  define event types
type EventTypes = 'EVENT_ONE' | 'EVENT_TWO'
const EVENTS: EventDef<EventTypes> = {
    EVENT_ONE : (msg: MsgTypes) => msg.type == 'T1',
    EVENT_TWO : 'T2' //short form: the type only
}
*/
// ===============================
// ========= file Subscription.ts / Core.ts==================
const ANY_EVENT: any = Symbol('any_event')
const TYPE_FILTER = (type:string) => (op:any, msg:any) => msg.type === type

class Connection {
  public listeners: Listener[] = [] 
  private autoProperties = new Map<number, AutoProperty>() 
  constructor(private eventDef?: EventDef<any>) { }

  send(op: any, msg: any): this {
    // make connection dependend work
    return this
  }

  receive(buf:any): this {
    // make connection dependend work
    //let { op, msg } = parseMessage(buf) 
    let op, msg
    this.onMessage(op, msg)
    return this
  }

  listen(h: EventHandler): this
  listen(f: MsgFilter, ap?: AutoProperty[]): this
  listen(f: MsgFilter, h: MsgHandler, ap?: AutoProperty[]): this
  listen(f: MsgFilter, h: EventHandler, ap?: AutoProperty[]): this
  listen(filterOrHander: MsgFilter | EventHandler, evtOrMsgOrAP?: EventHandler | MsgHandler | AutoProperty[], ap?:AutoProperty[]): this { 
    if (typeof filterOrHander === 'object') { //is an EventHandler
      this.listeners.push({ f: undefined, h: filterOrHander })
    } else {
      let _h, _p
      if (evtOrMsgOrAP instanceof Array) {
        this.listeners.push({ f: filterOrHander, h: undefined, p: evtOrMsgOrAP })
      } else if (typeof evtOrMsgOrAP == 'function') {
        let h = { [ANY_EVENT]: evtOrMsgOrAP }
        this.listeners.push({ f: filterOrHander, h: h, p: ap })
      } else { 
        this.listeners.push({ f: filterOrHander, h: evtOrMsgOrAP!, p: ap })
      }
    }
    return this
  }

  //connection with AutoProperty support added by proxy
  static create<M>(eventsDef?:EventDef<any>): AutoProperties<M> & Connection {
    return new Proxy(new Connection(eventsDef), {
      get(conn: any, name, receiver) {
        let idx:number=0
        return name in conn ? conn[name] :
          Object.defineProperty(
            new AutoPropertyConf(name, conn),
            'set', {
              // if setter set, activate autoProp
              set: function (setter) {
                if (idx>0) conn.autoProperties.delete(idx)
                if (setter) idx = conn.addAutoProperty(name, setter)
                else idx = 0
                return true
              }
            }
          )
      }
    })
  }

  private apNum=0
  private addAutoProperty(name: string, setter: (v: any) => void):number { 
    this.autoProperties.set(++this.apNum, { name: name, set: setter })
    return this.apNum
  }

  topicMatch(topic: string, pattern: string): boolean {
    if (!pattern || pattern == topic) return true;
    else if (!topic) return false;

    let expected = pattern.split('.')
    let actual = topic.split('.')
    if (expected.length > actual.length) return false

    for (let i = 0; i < actual.length; ++i) {
      if (actual[i] != expected[i] && expected[i] != "*")
        return false
    }
    return true
  }

  onMessage(op: any, msg: any):void {
    const isTopicMatch = (op: any, msg: any, f: MsgFilter) =>
                    typeof f === 'string' ? this.topicMatch(op, f) : f(op, msg)
    this.listeners.forEach((listener) => { 
      if (!listener.f || isTopicMatch(op, msg, listener.f)) {
        if (listener.h) {
          for (let eventId of Object.keys(listener.h)) {
            let cond = this.eventDef ? this.eventDef[eventId] : eventId
            //ToDo: extract msg.type default
            if (typeof cond === 'function' ? cond(op, msg) : msg.type == cond) {
              listener.h[eventId](op, msg)
            }
          }
          listener.h[ANY_EVENT]?.(op, msg)
        }
        //push values to autoProperties
        for (let ap of listener.p || []) {
          console.log(ap)
          ap && msg[ap.name] && ap.set(msg[ap.name])
        }
      }
    })
    //push values to autoProperties
    for (let ap of this.autoProperties.values()) {
      ap && msg[ap.name] && ap.set(msg[ap.name])
    }
  }

}//class Connection

class Core {
  static connect<M>(eventDef?:EventDef<any>): AutoProperties<M> & Connection {
    //ToDo: server specific
    return Connection.create(eventDef)
  }

  static wallet<M>(eventDef?:EventDef<any>): AutoProperties<M> & Connection {
    //ToDo: wallet specific
    return Connection.create(eventDef)
  }

  static overlay<M>(eventDef?:EventDef<any>): AutoProperties<M> & Connection {
    //ToDo: overlay specific
    return Connection.create(eventDef)
  }
}
// ========= file widgets.ts of dynamic adapter ===========

/*
type Ctx = {
  id:string
}

//Context related technical runtime info
type CtxRuntime = Ctx & {
  //save active subscriptions in ctx
  subs: WeakMap<Connection<any>,Subscription<any>>
}
type AutoPropertyConfig = { name: string, conn: Connection<any> }


*/
type WidgetState = { [key: string] : any}

function createState(stateCfg: WidgetState, ctxid: string, apSetters: {[key:string]:(v:any)=>any}) {
  let m=new Map<Connection,AutoPropertyConf[]>()
  let autoprops:AutoProperty[] = []
  Object.keys(stateCfg)
    .forEach((k: any) => Object.keys(stateCfg[k])
      .forEach((kk) => {
        let ap = stateCfg[k][kk]
        if (ap instanceof AutoPropertyConf) {
          if (!m.has(ap.conn)) m.set(ap.conn, [ap])
          else m.get(ap.conn)!.push(ap)
        }
      }))        
  for (let [conn, apCfgList] of m.entries()) {
    let apList = apCfgList.map((p: any) => ({ name: p.name, set: apSetters[p.name] }))
    conn.send('widget_start', ctxid)
      .listen(ctxid, apList)
  }
}

/*

    (stateName: string, v: any) => {
    currentState[name]?.cleanUp?.() //cleanup before rewrite property - remove autoprop from sub
    if (v[PROP]) {
      let { conn, name } = v[PROP] as AutoPropertyConfig
      let sub = ctx.subs.get(conn)
      if (!sub) ctx.subs.set(conn, sub = conn.subscribe(ctx.id))
      let cleanUp = sub.addAutoProp(name, (value: any) => currentState[name].value = value)
      currentState[name] = { cleanUp: cleanUp, value: undefined }
    } else {
      currentState[name] = { cleanUp: undefined, value: v }
    }
  })
}
*/
// ========= file MyFeature.ts ==================
type M1 = {
  type: string,
  topic: string
  p1: string
  p2: string
}

type M2 = {
  key0: string,
  key1: string
}





const EVENTS_DEF = {
  TX_SENT:    (op: any, m: any) => m.type === "TX_SENT",
  WC_CONNECT: (op: any, m: any) => m.type === "WC_CONNECT",
  SWARM_NODE: (op: any, m: any) => m.type === "SWARM_NODE",
  SWARM_SENT: "SWARM_SENT"
} 

let _conn = Core.connect<M1&M2>(EVENTS_DEF) //EVENTS_DEF - optional mapping
  .send('ping', {})
  .listen("the.topic", {
    TX_SENT: (op: any, m: any) => { console.log("onTxSent  topic:", m.topic) },
    WC_CONNECT: (op: any, m: any) => { console.log("onWalletConnect  topic:", m.topic) }
  })
  .listen({
    SWARM_NODE: (op: any, m: any) => { console.log("onSwarmNode topic:", m.topic) },
    SWARM_SENT: (op: any, m: any) => { console.log("onSwarmSent topic:", m.topic) }
  })
  .listen("swarm.*", (op: any, m: any) => { console.log("ANY_EVENT onSwarmNode topic:", m.topic)});

let ap0:any = _conn.topic
ap0.set = (v: any) => console.log('CONNECTION_SET TOPIC_No1', v); //this setter gets overwritten by the next line
ap0.set = (v: any) => console.log('CONNECTION_SET TOPIC No2', v);
let ap1:any = _conn.topic;
ap1.set = (v: any) => console.log('CONNECTION_SET TOPIC No3', v);
let ap2:AutoProperty = _conn.topic



let BTN_CONFIG = {
  DEFAULT: {
    topic: _conn.topic,
    p2: _conn.p2
  },
  NEXT: {
    img: 'transition.img',
    type: _conn.type
  },
  FINALIZED: {
    hello: 'abracadabra.'
  }
}

let apSetters = {
  'p1': (v: any) => console.log('[LISTENER SET.p1]'),
  'p2': (v: any) => console.log('[LISTENER SET.p2]'),
  'topic': (v: any) => console.log('[LISTENER SET.topic]'),
  'type': (v:any)=>console.log('[LISTENER SET.type]'),
}

let s = createState(BTN_CONFIG, "12345", apSetters)

_conn.onMessage('the.topic', { type: "WC_CONNECT", topic: "the.topic", p1:"1-1", p2:"1-2" })
_conn.onMessage('the.topic', { type: "TX_SENT", topic: "the.topic", p1:"2-1", p2:"2-2" })
_conn.onMessage('swarm.a', { type: "SWARM_NODE", topic: "swarm.topic",p1:"3-3", p2:"3-3" })
_conn.onMessage('swarm.b', { type: "SWARM_SENT", topic: "swarm.x" })
_conn.onMessage('12345', { type: "WC_CONNECT", topic: "the.topic", p1:"1-1", p2:"1-2" })